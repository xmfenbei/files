

#### io.netty.bootstrap
The helper classes with fluent API which enable an easy implementation of typical client side and server side channel initialization.

#### io.netty.buffer
Abstraction of a byte buffer - the fundamental data structure to represent a low-level binary and text message. Netty uses its own buffer API instead of NIO ByteBuffer to represent a sequence of bytes. This approach has significant advantage over using ByteBuffer. Netty's new buffer type, ByteBuf, has been designed from ground up to address the problems of ByteBuffer and to meet the daily needs of network application developers. To list a few cool features:
1. You can define your buffer type if necessary.
2. Transparent zero copy is achieved by built-in composite buffer type.
3. A dynamic buffer type is provided out-of-the-box, whose capacity is expanded on demand, just like StringBuffer.
4. There's no need to call the flip() method anymore.
5. It is often faster than ByteBuffer.

#### io.netty.channel
The core channel API which is asynchronous and event-driven abstraction of various transports such as a NIO Channel.

#### io.netty.handler.*

#### io.netty.resolver
Resolves an arbitrary string that represents the name of an endpoint into an address.

#### io.netty.util
Utility classes used across multiple packages.

#### 参考资料：
[Netty API Reference (4.1.24.Final)](https://netty.io/4.1/api/index.html)
